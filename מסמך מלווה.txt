הנחות יסוד:
לערך מותר להופיע כמה פעמים ברשימה, והוצאת המינימום מוציאה רק הופעה אחת של הערך מהרשימה

בכדי להריץ את הקוד דרך הטרמינל קובץ האינפוט צריך לשבת באותה תקייה עם הקוד
python ./main.py name_of_input_file.txt

שמות הרשימות האפשריים הם:
sorted, not sorted, foreigns

יש להזין כל פקודה בשורה נפרדת בקובץ (בדומה לקובץ הדוגמא שמצורף) 

מתוקף המבנה של הקוד, כל פוקנציה מתעודת בתוך הקוד עם הסבר על מה היא עושה והיעילות זמן שלה

הסבר על המבנה של רשימות ממויינות:
רשימה מקושרת דו קיוונית, בכל הכנסה עוברים על הרשימה בצורה לינארית בשביל למצוא את המיקום הנכון לאיבר שישמור על מיון הרשימה, האיבר הראשון הוא איבר המינימום ולכן מציאתו היא מיידית, כיוון והיא ממויינת גם הוצאת איבר המינימום היא מיידית, האיחוד נעשה על ידי מעבר על שתי הרשימות במקביל ובחירת האיבר הנמוך ביותר כל פעם, עד לסיום המעבר על הרשימות

(רשימה ראשית = רשימה של האיברים ללא הורים)
הסבר על המבנה של רשימה לא ממויינת וזרות:
רשימה מקושרת תלת כיוונית, לכל איבר יש שמאל ימין וילד, כאשר שמאל וימין מחזוריים וילד מוביל לתת רשימה בעלת שמאל ימין גם. 
ההכנסה מתבצעת על ידי דחיפת האיבר לרשימה והחלפה עם איבר המינימום אם הוא קטן ממנו, מציאת המינימום היא מיידית כיוון והמצביע הראשי לרשימה מתחיל מאיבר המינימום, הוצאת איבר המינימום מתבצעת בכמה שלבים: 
בודקים האם הרשימה ריקה, אם כן מסיימים, אם לא אז בדוקים האם יש לאיבר המינימום ילדים - אם כן אז מחזירים אותם לרשימה הראשית על ידי החלפת המצביעים
מוציאים את איבר המינימום מהרשימה, ומאחדים את הערימות: 
מייצרים שני מערכים, אחד בגודל 2*לוג(כמות האיברים ברשימה) ועוד רשימה עם מצביעים לאיברים ברשימה הראשית, שימוש הזיכרון במקרה הגרוע הוא:O(N)
במקרה הממוצע: O(lg(n))
במקרה הטוב: O(1) 
עבור כל איבר ברשימה הראשית בודקים מה הדרגה שלו (כמה ילדים מכונסים יש בתוכו), אם יש איבר אחר שזוהה בדרגה זאת אז מאחדים אותם על ידי הכנסת האיבר הגדול לרשימת הילדים של האיבר הקטן (מה ששומר על תכונת המינימום של האיברים), מעלים ב1 את דרגת האיבר אליו הוכנס האיבר, בודקים שוב האם יש איבר בדרגה החדשה.... שומרים במערך המוגדר מראש במיקום הדרגה החדשה את האיבר ועוברים לאיבר הבא
לאחר סיום המעבר על האיברים ברשימה הראשית, עוברים על המערך בו נשארו איברים - אלו הם האיברים השייכים לציר הראשי, נמצא מהם את איבר המינימום החדש ונעדכן את המצביע אליו.
איחוד מתבצע על ידי חיבור הרשימות הראשיות של שתי הערימות


הסבר על הכנסה לרשימות זרות:
בכל הכנסה לרשימה מתבצע וידוא כי הערך לא נמצא ברשימה אחרת כבר, כלומר עוברים על כל הרשימות. 
בכל רשימה החיפוש מתבצע על ידי הנחות הנובעות מתכונות מבנה הנתונים: אם הערך קטן מאיבר המינימום הוא בהכרח לא ברשימה ולא ילד של האיבר, בצורה זאת נמנע מלבדוק את כל האיברים בפועל (בהנחה ובוצעה הוצאה של המינימום קודם לכן) 
מתבצעת איסוף לערמה לפני החיפוש במטרה לשפר את זמן הריצה
החיפוש במקרה הרע לוקח: O(n^2) במצב בוא אף רשימה לא עברה הוצאת מינימום עדיין בכלל
במקרה הממוצע: O(nlg(n)) כל הרשימות עברו הוצאת מינימום 
במקרה הטוב: O(n) הערך נמוך מכל הערכים בכל הרשימות  



בנוסף לכל פונקציה יש תיעוד יעילות כהערה בקוד, בשפות אחרות המימוש עם רשימה של איברים לא היה נחוץ אבל בגלל איך שפייתון נותנת שימוש ב"הערכה עצלנית" אי אפשר לעשות זאת בצורה נקייה (הקלט משתנה תוך כדי שהגנרטור רץ עליו) 
בכל מקרה יש צורך למימוש זה בלפחות מערך לדרגות האיברים, ללא זה, זמן הריצה יעלה בצורה משמעותית עקב הוספה של לולאה למציאת האיבר בדרגה המתאימה (גם במימוש שמוסיף מצביע לצורך זה באיבר עצמו, הדבר גורר פגיעה משמעותית מידי בזמן הריצה) 



